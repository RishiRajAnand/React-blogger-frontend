import _extends from 'babel-runtime/helpers/extends';
import _objectWithoutProperties from 'babel-runtime/helpers/objectWithoutProperties';
/**
 * @file This file contains scroll picker components
 * @author mayingcong <mayingcong@xingxy.cn>
 * @date 2016-11-02
 */
import React from 'react';
import className from 'classnames';

import Button from './Button';

var PickerMixin = {
    closePicker: function closePicker() {
        this.setState({
            isPickerOpen: false
        });
        this.props.onClose();
    },
    confirmPicker: function confirmPicker() {
        var _state = this.state;
        var selectedIndexGroup = _state.selectedIndexGroup;
        var optionsGroup = _state.optionsGroup;

        var selectedValue = [];
        for (var i = 0; i < optionsGroup.length; i++) {
            selectedValue.push(optionsGroup[i][selectedIndexGroup[i] || 0]);
        }
        this.props.onSelected(selectedValue);
        this.closePicker();
    }
};

/**
 * BackDrop component
 * @author mayingcong <mayingcong@xingxy.cn>
 * @date   2016-11-02
 */
export var BackDrop = React.createClass({
    displayName: 'BackDrop',

    render: function render() {
        var _props = this.props;
        var isOpen = _props.isOpen;

        var props = _objectWithoutProperties(_props, ['isOpen']);

        var backdropClass = className('pop-picker-backdrop', {
            'in': isOpen
        });
        // e.preventDefault() in onTouchMove is used to prevent background scrolling
        return React.createElement('div', _extends({ className: backdropClass, onTouchMove: function onTouchMove(e) {
                e.preventDefault();
            } }, props));
    }
});

/**
 * PickerColumn component
 * Component of a column of options
 * @author mayingcong <mayingcong@xingxy.cn>
 * @date   2016-11-02
 */
export var PickerColumn = React.createClass({
    displayName: 'PickerColumn',

    propTypes: {
        columnIndex: React.PropTypes.number,
        defaultIndex: React.PropTypes.number,
        options: React.PropTypes.array,
        onSelected: React.PropTypes.func
    },

    shouldStopInertialMove: false,

    getInitialState: function getInitialState() {
        return _extends({
            startScrollTranslate: 0,
            isPicking: false
        }, this.calInitialState(this.props));
    },

    getDefaultProps: function getDefaultProps() {
        return {
            itemHeight: 36,
            lineNum: 5,
            options: [],
            selectedIndex: 0
        };
    },

    /**
     * Compute state due to props
     * @param  {Object}
     * @return {Object}
     */
    calInitialState: function calInitialState(props) {
        var options = props.options;
        var itemHeight = props.itemHeight;
        var selectedIndex = props.selectedIndex;

        return {
            itemHeight: itemHeight,
            selectedIndex: selectedIndex,
            minTranslate: -itemHeight * (options.length - 1),
            maxTranslate: 0,
            scrollTranslate: -itemHeight * selectedIndex
        };
    },

    componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
        this.setState(this.calInitialState(nextProps));
    },

    /**
     * calculate index according to scroll height
     * @param  {number}
     * @return {number}
     */
    calElementHighLight: function calElementHighLight(scrollTranslate) {
        var itemHeight = this.state.itemHeight;

        var index = Math.round(Math.abs(scrollTranslate / itemHeight));
        this.setState({
            selectedIndex: index
        });
        return index;
    },

    /**
     * Touch start event callback
     * @event
     * @param  {Event}
     */
    handleTouchStart: function handleTouchStart(e) {
        var startTouchY = e.targetTouches[0].pageY;
        this.setState(function (_ref) {
            var scrollTranslate = _ref.scrollTranslate;
            return {
                isPicking: true,
                startTouchY: startTouchY,
                transitionDuration: 0,
                startScrollTranslate: scrollTranslate
            };
        });
        this.updateInertialFlag(e, true);
    },

    /**
     * TouchMove event callback
     * @event
     * @param  {Event}
     */
    handleTouchMove: function handleTouchMove(e) {
        e.preventDefault();
        var touchY = e.targetTouches[0].pageY;
        var _state2 = this.state;
        var isPicking = _state2.isPicking;
        var minTranslate = _state2.minTranslate;
        var maxTranslate = _state2.maxTranslate;
        var startTouchY = _state2.startTouchY;
        var startScrollTranslate = _state2.startScrollTranslate;
        var itemHeight = this.props.itemHeight;

        if (!isPicking) return;
        var nextScrollTranslate = startScrollTranslate + touchY - startTouchY;
        // calculate translate distance if exceeding [minTranslate, maxTranslate]
        if (nextScrollTranslate < minTranslate - 1.5 * itemHeight) {
            nextScrollTranslate = minTranslate - 1.5 * itemHeight;
        } else if (nextScrollTranslate > maxTranslate + 1.5 * itemHeight) {
            nextScrollTranslate = maxTranslate + 1.5 * itemHeight;
        }
        this.setState({
            scrollTranslate: nextScrollTranslate
        });
        this.calElementHighLight(nextScrollTranslate);
        this.updateInertialFlag(e);
    },

    /**
     * TouchEnd event callback
     * @event
     * @param  {Event}
     */
    handleTouchEnd: function handleTouchEnd(e) {
        this.setState({
            isPicking: false
        });
        this.startInertialScroll(e);
    },

    /**
     * TouchCancel event callback
     * @event
     * @param  {Event}
     */
    handleTouchCancel: function handleTouchCancel(e) {
        e.preventDefault();
        this.setState({
            isPicking: false
        });
        this.startInertialScroll(e);
    },

    /**
     * Get prepared for inertial scroll, which means getting inertial distance and duration
     * @param  {Event}
     */
    startInertialScroll: function startInertialScroll(e) {
        var point = e.changedTouches ? e.changedTouches[0] : e;
        var nowTime = e.timeStamp || Date.now();
        var velocity = (point.pageY - this.state.lastMoveStart) / (nowTime - this.state.lastMoveTime); // 最后一段时间手指滑动速度
        var direction = velocity > 0 ? -1 : 1; // decelaration direction
        var decelaration = direction * 0.0006 * -1;
        var duration = Math.abs(velocity / decelaration); // time for decelaration
        var distance = velocity * duration / 2; // distance during decelaration
        var _state3 = this.state;
        var itemHeight = _state3.itemHeight;
        var scrollTranslate = _state3.scrollTranslate;
        var minTranslate = _state3.minTranslate;
        var maxTranslate = _state3.maxTranslate;

        if (distance === 0) {
            // if distance equals 0, there is no need to scrollDist, just do endScroll
            this.endScroll();
            return;
        }
        var oldDistance = distance;
        if (scrollTranslate + distance < minTranslate - itemHeight) {
            distance = minTranslate - scrollTranslate - itemHeight;
            duration = duration * (distance / oldDistance) * 0.6;
        } else if (scrollTranslate + distance > maxTranslate + itemHeight) {
            distance = maxTranslate - scrollTranslate + itemHeight;
            duration = duration * (distance / oldDistance) * 0.6;
        }
        this.scrollDist(this.state.scrollTranslate, distance, duration);
    },

    /**
     * Translate animation 
     * @param  {number}
     * @param  {number} 
     * @param  {number}
     */
    scrollDist: function scrollDist(startTranslate, distance, duration) {
        var self = this;
        self.shouldStopInertialMove = false;
        var frameInterval = 13;
        var stepCount = duration / frameInterval;
        var stepIndex = 0;
        (function inertiaMove() {
            if (self.shouldStopInertialMove) return;
            var newDistance = self.quartEaseOut(stepIndex, startTranslate, distance, stepCount);
            self.setState({
                scrollTranslate: newDistance
            });
            self.calElementHighLight(newDistance);
            stepIndex++;
            if (stepIndex > stepCount - 1 || newDistance < self.minTranslate || newDistance > self.maxTranslate) {
                self.endScroll();
                return;
            }
            setTimeout(inertiaMove, frameInterval);
        })(startTranslate, distance, duration);
    },
    quartEaseOut: function quartEaseOut(t, b, c, d) {
        return -c * ((t = t / d - 1) * t * t * t - 1) + b;
    },

    /**
     * Move to the rigth place after inertial scroll
     */
    endScroll: function endScroll() {
        var _state4 = this.state;
        var minTranslate = _state4.minTranslate;
        var maxTranslate = _state4.maxTranslate;
        var scrollTranslate = _state4.scrollTranslate;
        var itemHeight = _state4.itemHeight;

        var finalTranslate = scrollTranslate;
        var transitionDuration = 150;
        if (scrollTranslate < minTranslate) {
            finalTranslate = minTranslate;
        } else if (scrollTranslate > maxTranslate) {
            finalTranslate = maxTranslate;
        } else {
            finalTranslate = -itemHeight * Math.round(-scrollTranslate / itemHeight);
            transitionDuration = 100;
        }
        this.setState({
            transitionDuration: transitionDuration,
            scrollTranslate: finalTranslate
        });
        this.triggerSelect(this.calElementHighLight(finalTranslate));
    },

    /**
     * Update the shouldStopInertialMove flag
     * @param  {Event}
     * @param  {Boolean}
     */
    updateInertialFlag: function updateInertialFlag(e, isStart) {
        var point = e.targetTouches ? e.targetTouches[0] : e;
        if (isStart) {
            this.setState({
                lastMoveTime: e.timeStamp || Date.now(),
                lastMoveStart: point.pageY
            });
            this.shouldStopInertialMove = true;
        } else {
            var nowTime = e.timeStamp || Date.now();
            if (nowTime - this.state.lastMoveTime > 300) {
                this.setState({
                    lastMoveTime: nowTime,
                    lastMoveStart: point.pageY
                });
                this.shouldStopInertialMove = true;
            }
        }
    },

    /**
     * Trigger select action
     * @param  {number} finally selected index
     */
    triggerSelect: function triggerSelect(index) {
        var options = this.props.options;

        this.props.onSelected(options[index], index, this.props.columnIndex);
    },

    /**
     * Set selectedIndex and scrollTranslate
     * @param  {number}
     */
    selectItem: function selectItem(index) {
        var itemHeight = this.state.itemHeight;

        this.setState({
            selectedIndex: index,
            scrollTranslate: -itemHeight * index,
            transitionDuration: 150
        });
        this.triggerSelect(index);
    },

    /**
     * Render every single option
     * @return {Array}
     */
    renderItem: function renderItem() {
        var options = this.props.options;
        var selectedIndex = this.state.selectedIndex;

        var self = this;
        !selectedIndex && (selectedIndex = 0);
        return options.map(function (option, index) {
            var className = index === selectedIndex ? 'highlight' : '';
            return React.createElement(
                'li',
                { key: index, className: className, onClick: function onClick() {
                        self.selectItem(index);
                    } },
                option.name
            );
        });
    },
    render: function render() {
        var translateString = 'translate3d(0, ' + this.state.scrollTranslate + 'px, 0)';
        var style = {
            MsTransform: translateString,
            MozTransform: translateString,
            OTransform: translateString,
            WebkitTransform: translateString,
            transform: translateString
        };
        style.transitionDuration = this.state.transitionDuration + 'ms';
        return React.createElement(
            'ul',
            { className: 'pop-picker-scroller',
                onTouchStart: this.handleTouchStart,
                onTouchMove: this.handleTouchMove,
                onTouchEnd: this.handleTouchEnd,
                onTouchCancel: this.handleTouchCancel,
                style: style
            },
            this.renderItem()
        );
    }
});

/**
 * PickerHeader component which stands an the head of each Picker
 */
export var PickerHeader = React.createClass({
    displayName: 'PickerHeader',

    propTypes: {
        closePicker: React.PropTypes.func,
        confirmPicker: React.PropTypes.func,
        colorStyle: React.PropTypes.string
    },

    getDefaultProps: function getDefaultProps() {
        return {
            closePicker: function closePicker() {},
            confirmPicker: function confirmPicker() {},
            colorStyle: 'primary'
        };
    },

    render: function render() {
        var _props2 = this.props;
        var closePicker = _props2.closePicker;
        var confirmPicker = _props2.confirmPicker;
        var colorStyle = _props2.colorStyle;

        var btnClass = className('btn-xs', 'btn-' + colorStyle);
        return React.createElement(
            'div',
            { className: 'pop-picker-header', onTouchMove: function onTouchMove(e) {
                    e.preventDefault();
                } },
            React.createElement(
                Button,
                { className: 'btn-xs', onClick: closePicker },
                '\u53D6\u6D88'
            ),
            React.createElement(
                Button,
                { className: btnClass, style: { 'float': 'right' }, onClick: confirmPicker },
                '\u786E\u5B9A'
            )
        );
    }
});

/**
 * Picker component which contains PickerHeader, PickerColumn and BackDrop
 */
var Picker = React.createClass({
    displayName: 'Picker',

    mixins: [PickerMixin],
    propTypes: {
        className: React.PropTypes.string,
        colorStyle: React.PropTypes.string,
        columnNum: React.PropTypes.number,
        selectedIndexGroup: React.PropTypes.array,
        isCascading: React.PropTypes.bool,
        isPickerOpen: React.PropTypes.bool,
        itemHeight: React.PropTypes.number,
        lineNum: React.PropTypes.number,
        optionsGroup: React.PropTypes.array,
        onChange: React.PropTypes.func,
        onClose: React.PropTypes.func,
        onSelected: React.PropTypes.func
    },

    getInitialState: function getInitialState() {
        return _extends({
            isPickerOpen: this.props.isPickerOpen
        }, this.filterOptions());
    },

    getDefaultProps: function getDefaultProps() {
        return {
            className: '',
            selectedIndexGroup: null, // default selected index array
            isPickerOpen: false, // whether to open picker. true means open
            isCascading: false, // whether the column is cascadable
            columnNum: -1, // how many columns to display. Default -1, means to display all arrays you provided
            lineNum: 5, // how many lines to display
            itemHeight: 36, // height of each item
            optionsGroup: [], // options to display
            onChange: function onChange() {},
            onClose: function onClose() {},
            onSelected: function onSelected() {}
        };
    },

    /**
     * filter options for different use(whether cascading or not)
     */
    filterOptions: function filterOptions() {
        var _props3 = this.props;
        var selectedIndexGroup = _props3.selectedIndexGroup;
        var isCascading = _props3.isCascading;
        var columnNum = _props3.columnNum;
        var optionsGroup = _props3.optionsGroup;

        // if state exits and selectedIndecGroup exits, use this.state.selectedIndexGroup instead
        // selectedIndexGroup = (this.state && this.state.selectedIndexGroup) || (selectedIndexGroup && Array.isArray(selectedIndexGroup) ? selectedIndexGroup : [0]);

        selectedIndexGroup = selectedIndexGroup || [];
        if (isCascading) {
            // if column is cascadable, get displayed column options due to default selected index
            columnNum = columnNum === -1 ? 1 : columnNum;
            var columnList = [];
            for (var i = 0, optionList = optionsGroup; i < columnNum; i++) {
                columnList.push(optionList);
                selectedIndexGroup[i] = selectedIndexGroup[i] || 0;
                optionList = optionList[selectedIndexGroup[i]].children || [];
            }
            return {
                optionsGroup: columnList,
                selectedIndexGroup: selectedIndexGroup
            };
        } else {
            var _columnList = [];
            if (columnNum === -1) {
                // if not set columnNum, default to display all arrays you provided
                if (Array.isArray(optionsGroup[0])) {
                    _columnList = optionsGroup;
                } else {
                    _columnList.push(optionsGroup);
                }
            } else {
                var length = Array.isArray(optionsGroup[0]) ? optionsGroup.length : 1;
                for (var _i = 0; _i < columnNum && _i < length; _i++) {
                    _columnList.push(optionsGroup[_i]);
                }
            }
            return {
                optionsGroup: _columnList,
                selectedIndexGroup: selectedIndexGroup
            };
        }
    },

    componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
        this.setState(_extends({
            isPickerOpen: nextProps.isPickerOpen
        }, this.filterOptions()));
    },

    /**
     * Callback when item selected
     * @event
     * @param  {Object}
     * @param  {number} index of selected item
     * @param  {number} index of selected column
     */
    onChange: function onChange(selectedValue, itemIndex, columnIndex) {
        var _props4 = this.props;
        var columnNum = _props4.columnNum;
        var isCascading = _props4.isCascading;
        var _state5 = this.state;
        var optionsGroup = _state5.optionsGroup;
        var selectedIndexGroup = _state5.selectedIndexGroup;

        if (isCascading) {
            // change children column
            for (var i = columnIndex + 1; i < columnNum; i++) {
                if (i === columnIndex + 1) {
                    optionsGroup[i] = optionsGroup[i - 1][itemIndex].children || [];
                } else {
                    optionsGroup[i] = optionsGroup[i - 1][0].children || [];
                }
                selectedIndexGroup[i] = selectedIndexGroup[i] < optionsGroup[i].length ? selectedIndexGroup[i] : 0;
            }
        }
        selectedIndexGroup[columnIndex] = itemIndex;
        this.setState({
            optionsGroup: optionsGroup,
            selectedIndexGroup: selectedIndexGroup
        });
    },

    /**
     * Render PickerColumn
     */
    renderColumns: function renderColumns() {
        var _this = this;

        var _state6 = this.state;
        var optionsGroup = _state6.optionsGroup;
        var selectedIndexGroup = _state6.selectedIndexGroup;


        return React.createElement(
            'div',
            { className: 'pop-picker-container' },
            optionsGroup.length ? optionsGroup.map(function (value, index) {
                return React.createElement(
                    'div',
                    { className: 'pop-picker-inner', key: index },
                    React.createElement(PickerColumn, {
                        columnIndex: index,
                        selectedIndex: selectedIndexGroup && typeof selectedIndexGroup[index] === 'number' ? selectedIndexGroup[index] : 0,
                        itemHeight: _this.props.itemHeight,
                        onSelected: _this.onChange,
                        options: value
                    }),
                    React.createElement('div', { className: 'pop-picker-rule pop-picker-rule-bg' })
                );
            }) : ''
        );
    },
    render: function render() {
        var _this2 = this;

        var popPickerClass = className('pop-picker', this.props.className, {
            'in': this.state.isPickerOpen
        });
        var _props5 = this.props;
        var lineNum = _props5.lineNum;
        var itemHeight = _props5.itemHeight;

        var popPickerBodyStyle = {
            'boxSizing': 'content-box',
            height: lineNum * itemHeight + 'px'
        };
        return React.createElement(
            'div',
            null,
            React.createElement(
                'div',
                { className: popPickerClass, onTouchMove: function onTouchMove(e) {
                        e.preventDefault();
                    } },
                React.createElement(PickerHeader, { colorStyle: this.props.colorStyle, confirmPicker: this.confirmPicker, closePicker: this.closePicker }),
                React.createElement(
                    'div',
                    { className: 'pop-picker-body', style: popPickerBodyStyle },
                    this.renderColumns()
                )
            ),
            React.createElement(BackDrop, { isOpen: this.state.isPickerOpen, onClick: function onClick() {
                    _this2.closePicker();
                } })
        );
    }
});

/**
 * Date Picker Component
 */
export var DatePicker = React.createClass({
    displayName: 'DatePicker',

    mixins: [PickerMixin],
    PropTypes: {
        startTime: React.PropTypes.string,
        endTime: React.PropTypes.string
    },
    getInitialState: function getInitialState() {
        return _extends({
            selectedIndexGroup: [0, 0]
        }, this.computeState(this.props));
    },
    getDefaultProps: function getDefaultProps() {
        return {};
    },
    componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
        this.setState({
            isPickerOpen: nextProps.isPickerOpen
        });
    },
    /**
     * Get Date Options for Picker
     * @param  {Date} start date time for Picker
     * @param  {Date} end date time for Picker
     * @param  {Date} selected time
     * @param  {number} slice start index
     * @param  {number} slice end index
     * @return {Object}
     */
    getDateOptionsGroup: function getDateOptionsGroup(startTime, endTime, selectedTime, startIndex, endIndex) {
        var year = [];
        var month = [];
        var date = [];
        var hour = [];
        var minute = [];
        var second = [];
        var optionsGroup = [year, month, date, hour, minute, second];
        var selectedIndexGroup = [0, 0, 0, 0, 0, 0];
        var titles = ['年', '月', '日', '时', '分', '秒', '时段'];
        for (var i = startTime.getFullYear(); i <= endTime.getFullYear(); i++) {
            if (selectedTime.getFullYear() === i) selectedIndexGroup[0] = i - startTime.getFullYear();
            year.push({
                id: i,
                name: i
            });
        }
        for (var _i2 = 1; _i2 <= 12; _i2++) {
            if (selectedTime.getMonth() + 1 === _i2) selectedIndexGroup[1] = _i2 - 1;
            month.push({
                id: _i2,
                name: _i2 < 10 ? '0' + _i2 : _i2
            });
        }
        for (var _i3 = 1; _i3 <= this.getDaysofMonth(selectedTime); _i3++) {
            if (selectedTime.getDate() === _i3) selectedIndexGroup[2] = _i3;
            date.push({
                id: _i3,
                name: _i3 < 10 ? '0' + _i3 : _i3
            });
        }
        for (var _i4 = 0; _i4 <= 23; _i4++) {
            if (selectedTime.getHours() + 1 === _i4) selectedIndexGroup[3] = _i4;
            hour.push({
                id: _i4,
                name: _i4 < 10 ? '0' + _i4 : _i4
            });
        }
        for (var _i5 = 0; _i5 <= 59; _i5++) {
            if (selectedTime.getMinutes() + 1 === _i5) selectedIndexGroup[4] = _i5;
            minute.push({
                id: _i5,
                name: _i5 < 10 ? '0' + _i5 : _i5
            });
        }
        for (var _i6 = 1; _i6 <= 59; _i6++) {
            if (selectedTime.getSeconds() + 1 === _i6) selectedIndexGroup[5] = _i6;
            second.push({
                id: _i6,
                name: _i6 < 10 ? '0' + _i6 : _i6
            });
        }
        return {
            optionsGroup: optionsGroup.slice(startIndex, endIndex),
            selectedIndexGroup: selectedIndexGroup.slice(startIndex, endIndex),
            titles: titles.slice(startIndex, endIndex)
        };
    },

    /**
     * Get total days of a month
     * @param  {Date}
     * @return {number}
     */
    getDaysofMonth: function getDaysofMonth(dateTime) {
        var year = dateTime.getFullYear();
        var month = dateTime.getMonth() + 1;
        return new Date(year, month, 0).getDate();
    },

    /**
     * Compute state due to props
     * @param  {Object} the props of this component
     * @return {[type]}
     */
    computeState: function computeState(props) {
        var startTime = props.startTime ? new Date(props.startTime) : new Date('1910');
        var currentTime = new Date();
        var endTime = props.endTime ? new Date(props.endTime) : new Date(currentTime.getFullYear() + 5, currentTime.getMonth() + 1, currentTime.getDate());
        switch (props.type) {
            case 'date':
                return this.getDateOptionsGroup(startTime, endTime, currentTime, 0, 3);
            case 'time':
                return this.getDateOptionsGroup(startTime, endTime, currentTime, 3, 6);
            case 'month':
                return this.getDateOptionsGroup(startTime, endTime, currentTime, 0, 2);
            case 'hour':
                return this.getDateOptionsGroup(startTime, endTime, currentTime, 0, 4);
            case 'minute':
                return this.getDateOptionsGroup(startTime, endTime, currentTime, 0, 5);
            default:
                return this.getDateOptionsGroup(startTime, endTime, currentTime, 0, 6);
        }
    },
    onChange: function onChange(selectedValue, itemIndex, columnIndex) {
        var _props6 = this.props;
        var columnNum = _props6.columnNum;
        var isCascading = _props6.isCascading;
        var _state7 = this.state;
        var optionsGroup = _state7.optionsGroup;
        var selectedIndexGroup = _state7.selectedIndexGroup;

        if (isCascading) {
            for (var i = columnIndex + 1; i < columnNum; i++) {
                if (i == columnIndex + 1) optionsGroup[i] = optionsGroup[i - 1][itemIndex].children || [];else optionsGroup[i] = optionsGroup[i - 1][0].children || [];
            }
        }
        selectedIndexGroup[columnIndex] = itemIndex;
        this.setState({
            optionsGroup: optionsGroup,
            selectedIndexGroup: selectedIndexGroup
        });
    },
    renderInner: function renderInner() {
        var _state8 = this.state;
        var optionsGroup = _state8.optionsGroup;
        var selectedIndexGroup = _state8.selectedIndexGroup;

        var self = this;
        return React.createElement(
            'div',
            { className: 'pop-picker-container' },
            optionsGroup.length ? optionsGroup.map(function (value, index) {
                return React.createElement(
                    'div',
                    { className: 'pop-picker-inner', key: index },
                    React.createElement(PickerColumn, {
                        columnIndex: index,
                        options: value,
                        defaultIndex: selectedIndexGroup[index],
                        onSelected: self.onChange
                    }),
                    React.createElement('div', { className: 'pop-picker-rule pop-picker-rule-bg' })
                );
            }) : ''
        );
    },
    render: function render() {
        var backdropClass = className('pop-picker-backdrop', {
            'in': this.state.isPickerOpen
        });
        var popPickerClass = className('pop-picker', {
            'in': this.state.isPickerOpen
        });
        return React.createElement(
            'div',
            null,
            React.createElement(
                'div',
                { className: popPickerClass },
                React.createElement(PickerHeader, { confirmPicker: this.confirmPicker, closePicker: this.closePicker }),
                React.createElement(
                    'div',
                    { className: 'pop-picker-title' },
                    this.state.titles.map(function (value, index) {
                        return React.createElement(
                            'div',
                            { key: index },
                            value
                        );
                    })
                ),
                React.createElement(
                    'div',
                    { className: 'pop-picker-body' },
                    this.renderInner()
                )
            ),
            this.state.isPickerOpen ? React.createElement('div', { className: backdropClass, onClick: this.closePicker }) : ''
        );
    }
});
export default Picker;